/* Дан целочисленный параметр n. 
Верните функцию-счётчик. Эта функция-счётчик изначально возвращает n, 
а затем каждый последующий раз при вызове возвращает значение на 1 больше предыдущего (n, n + 1, n + 2 и т.д.). */

// 1 cлучай

 const createCounter = (n) => {

   return function () {
     return n++;
   };

 };
 
 let count = createCounter(10)

console.log( count() )    
console.log( count() );  


// 2 случай

 const createCounter2 = (n) => {

   return function () {
     return n++;
   };


 }

 console.log(createCounter2(10)());
 console.log(createCounter2(10)());  

 /*  В первом случае  создаётcя один экземпляр функции-счётчика и присваивается переменной count.
  Эта функция использует замыкание (closure) на переменной n, которая хранится в памяти и изменяется при каждом вызове. Поэтому:
  Первый вызов count() возвращает текущее n (10) и затем инкрементирует его постфиксным оператором n++ (становится 11).
  Второй вызов count() видит уже изменённое n (11), возвращает его и инкрементирует до 12.

Состояние сохраняется между вызовами, потому что это одна и та же функция.
Во втором случае вы каждый раз создаёте новый экземпляр функции-счётчика и сразу вызываете его:
createCounter2(10)(): создаётся новая функция с собственным замыканием на свежем n=10, возвращает 10 и инкрементирует до 11 (но это значение никуда не используется дальше).
Следующий createCounter2(10)(): снова новая функция с новым n=10, возвращает 10.
 
 */